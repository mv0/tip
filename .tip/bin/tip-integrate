#!/bin/sh
#
# Automatically merge the branches for a given integration branch
#

. $(dirname "$0")/tip-lib

check_master

BRANCH=$1

git-checkout tip
if [ ! -f  .tip/auto-branches/$BRANCH ]
then
    echo "usage: tip-integrate integration-branch"
    echo "available integration branches:"
    BS=`get_auto_branches`
    for B in $BS; do echo "    $B"; done
    git-checkout master
    exit 1;
fi

# Read the branch list
git-checkout tip
MB=`cat .tip/auto-branches/$BRANCH | grep -v "^[# \n]"`
# switch back to linus
git-checkout linus
# Blow away the existing integration branches and create a new one
git-branch -f $BRANCH-base
git-branch -f $BRANCH
# Build the new integration branch
git-checkout $BRANCH

for B in $MB
do
    echo "Merging $B"
    git-merge $B 2>.merge.log >.merge.log0 || {

	cat .merge.log
        cat .merge.log0

	# stupid special for lack of git-rm support in git-rerere:
        grep -q 'arch/x86/kernel/nmi_32.c deleted in x86/nmi and modified in HEAD' .merge.log0 && git-rm arch/x86/kernel/nmi_32.c

	NR_AUTO=$(grep -E '^Resolved .* using previous resolution.$' .merge.log | wc -l)
	NR_PENDING=$(git-ls-files -u | cut -f2 | uniq | wc -l)

	[ "$NR_AUTO" = "$NR_PENDING" ] && {
            echo "Found $NR_AUTO auto-merged files - committing them."
	    git-add $(git-ls-files -u | cut -f2 | sort | uniq)
	    git-commit -n -s -m "manual merge of $B" || abort_merge;
            continue;
        }

	echo
	echo Merging $B into $BRANCH failed
	echo merge conflict - run tip-mergetool
	echo
	echo running subshell - type "exit" when resolved
	$SHELL || abort_merge

	NCOM=`git-ls-files -u`
	if [ ! -z "$NCOM" ]
	then
	    echo "Merge was not committed! Fixing it up"
	    git-add $(git-ls-files -u | cut -f2 | sort | uniq)
	    git-commit -n -s || abort_merge;
	fi
    }
done

# switch back to master again
git-checkout master

echo "integration of $1 done."
